"use strict";(self.webpackChunkzio_site=self.webpackChunkzio_site||[]).push([[81160],{95788:(e,t,a)=>{a.d(t,{Iu:()=>c,yg:()=>m});var r=a(11504);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},s=Object.keys(e);for(r=0;r<s.length;r++)a=s[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)a=s[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=r.createContext({}),p=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},f="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},y=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),f=p(a),y=n,m=f["".concat(l,".").concat(y)]||f[y]||u[y]||s;return a?r.createElement(m,i(i({ref:t},c),{},{components:a})):r.createElement(m,i({ref:t},c))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=a.length,i=new Array(s);i[0]=y;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[f]="string"==typeof e?e:n,i[1]=o;for(var p=2;p<s;p++)i[p]=a[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}y.displayName="MDXCreateElement"},75200:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var r=a(45072),n=(a(11504),a(95788));const s={id:"examples",title:"Examples"},i=void 0,o={unversionedId:"reference/test/assertions/examples",id:"reference/test/assertions/examples",title:"Examples",description:"Example 1: Equality Assertion",source:"@site/docs/reference/test/assertions/examples.md",sourceDirName:"reference/test/assertions",slug:"/reference/test/assertions/examples",permalink:"/reference/test/assertions/examples",draft:!1,editUrl:"https://github.com/zio/zio/edit/series/2.x/docs/reference/test/assertions/examples.md",tags:[],version:"current",frontMatter:{id:"examples",title:"Examples"},sidebar:"reference-sidebar",previous:{title:"Built-in Assertions",permalink:"/reference/test/assertions/built-in-assertions"},next:{title:"How it Works?",permalink:"/reference/test/assertions/how-it-works"}},l={},p=[{value:"Example 1: Equality Assertion",id:"example-1-equality-assertion",level:2},{value:"Example 2: Field-level Assertion",id:"example-2-field-level-assertion",level:2},{value:"Example 3: Test if a ZIO Effect Fails With a Particular Error Type",id:"example-3-test-if-a-zio-effect-fails-with-a-particular-error-type",level:2},{value:"Example 4: Test if a ZIO Effect Fails With a Subtype of a Particular Error Type",id:"example-4-test-if-a-zio-effect-fails-with-a-subtype-of-a-particular-error-type",level:2}],c={toc:p},f="wrapper";function u(e){let{components:t,...a}=e;return(0,n.yg)(f,(0,r.c)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.yg)("h2",{id:"example-1-equality-assertion"},"Example 1: Equality Assertion"),(0,n.yg)("p",null,'Assume we have a function that concatenates two strings. One simple property of this function would be "the sum of the length of all inputs should be equal to the length of the output". Let\'s see an example of how we can make an assertion about this property:'),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\n\ntest("The sum of the lengths of both inputs must equal the length of the output") {\n  check(Gen.string, Gen.string) { (a, b) =>\n    assert((a + b).length)(Assertion.equalTo(a.length + b.length))\n  }\n}\n')),(0,n.yg)("p",null,"The syntax of assertion in the above code, is ",(0,n.yg)("inlineCode",{parentName:"p"},"assert(expression)(assertion)"),". The first section is an expression of type ",(0,n.yg)("inlineCode",{parentName:"p"},"A")," which is ",(0,n.yg)("em",{parentName:"p"},"result")," of our computation and the second one is the expected assertion of type ",(0,n.yg)("inlineCode",{parentName:"p"},"Assertion[A]"),"."),(0,n.yg)("h2",{id:"example-2-field-level-assertion"},"Example 2: Field-level Assertion"),(0,n.yg)("p",null,"There is also an easy way to test an object's data for certain assertions with ",(0,n.yg)("inlineCode",{parentName:"p"},"hasField")," which accepts besides a name, a mapping function from object to its tested property, and ",(0,n.yg)("inlineCode",{parentName:"p"},"Assertion")," object which will validate this property. Here our test checks if a person has at least 18 years and is not from the USA."),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-scala"},'import zio.test._\nimport zio.test.Assertion.{isRight, isSome,equalTo, isGreaterThanEqualTo, not, hasField}\n\nfinal case class Address(country:String, city:String)\nfinal case class User(name:String, age:Int, address: Address)\n\ntest("Rich checking") {\n  assert(\n    User("Jonny", 26, Address("Denmark", "Copenhagen"))\n  )(\n    hasField("age", (u:User) => u.age, isGreaterThanEqualTo(18)) &&\n    hasField("country", (u:User) => u.address.country, not(equalTo("USA")))\n  )\n}\n')),(0,n.yg)("p",null,"What is nice about those tests is that test reporters will tell you exactly which assertion was broken. Let's say we would change ",(0,n.yg)("inlineCode",{parentName:"p"},"isGreaterThanEqualTo(18)")," to ",(0,n.yg)("inlineCode",{parentName:"p"},"isGreaterThanEqualTo(40)")," which will fail. Print out on the console will be a nice detailed text explaining what exactly went wrong:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-bash"},'[info]       User(Jonny,26,Address(Denmark,Copenhagen)) did not satisfy (hasField("age", _.age, isGreaterThanEqualTo(45)) && hasField("country", _.country, not(equalTo(USA))))\n[info]       26 did not satisfy isGreaterThanEqualTo(45)\n')),(0,n.yg)("h2",{id:"example-3-test-if-a-zio-effect-fails-with-a-particular-error-type"},"Example 3: Test if a ZIO Effect Fails With a Particular Error Type"),(0,n.yg)("p",null,"The following example shows how to test if a ZIO effect fails with a particular error type. To test if a ZIO effect fails with a particular error type, we can use the ",(0,n.yg)("inlineCode",{parentName:"p"},"ZIO#exit")," to determine the exit type of that effect. "),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test.{ test, _ }\nimport zio.test.Assertion._\n\ncase class MyError(msg: String) extends Exception\n\nval effect: ZIO[Any, MyError, Unit] = ZIO.fail(MyError("my error msg"))\n\ntest("test if a ZIO effect fails with a particular error type") {\n  for {\n    exit <- effect.exit\n  } yield assertTrue(exit == Exit.fail(MyError("my error msg")))\n}\n')),(0,n.yg)("p",null,"The exit method on a ZIO effect returns an ",(0,n.yg)("inlineCode",{parentName:"p"},"Exit")," value, which represents the outcome of the effect. The ",(0,n.yg)("inlineCode",{parentName:"p"},"Exit")," value can be either ",(0,n.yg)("inlineCode",{parentName:"p"},"Exit.succeed")," or ",(0,n.yg)("inlineCode",{parentName:"p"},"Exit.fail"),". If the effect succeeded, the ",(0,n.yg)("inlineCode",{parentName:"p"},"Exit.succeed")," value will contain the result of the effect. If the effect failed, the ",(0,n.yg)("inlineCode",{parentName:"p"},"Exit.fail")," value will contain the error that caused the failure."),(0,n.yg)("h2",{id:"example-4-test-if-a-zio-effect-fails-with-a-subtype-of-a-particular-error-type"},"Example 4: Test if a ZIO Effect Fails With a Subtype of a Particular Error Type"),(0,n.yg)("p",null,"To test if a ZIO effect fails with a ",(0,n.yg)("inlineCode",{parentName:"p"},"subtype")," of a particular error type, we can use the ",(0,n.yg)("inlineCode",{parentName:"p"},"assertZIO")," function and the two ",(0,n.yg)("inlineCode",{parentName:"p"},"fails"),", and ",(0,n.yg)("inlineCode",{parentName:"p"},"isSubtype")," assertions from the zio-test library. The ",(0,n.yg)("inlineCode",{parentName:"p"},"assertZIO")," function takes a ZIO effect and an assertion. The assertion is called with the result of the ZIO effect. If the assertion returns true, then the ",(0,n.yg)("inlineCode",{parentName:"p"},"assertZIO")," will succeed, otherwise it will fail."),(0,n.yg)("p",null,"Assume we have these error types:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-scala"},"sealed trait MyError extends Exception\ncase class E1(msg: String) extends MyError\ncase class E2(msg: String) extends MyError\n")),(0,n.yg)("p",null,"To assert if an error type is a subtype of a particular error type, we need to combine the ",(0,n.yg)("inlineCode",{parentName:"p"},"fails")," and ",(0,n.yg)("inlineCode",{parentName:"p"},"isSubtype")," assertions together:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-scala"},"import zio.test.Assertion._\n\nAssertion.fails(isSubtype[MyError](anything))\n")),(0,n.yg)("p",null,"Now let's look at an example:"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-scala"},'import zio._\nimport zio.test.{ test, _ }\nimport zio.test.Assertion._\n\nval effect = ZIO.fail(E1("my error msg"))\n\ntest("Test if a ZIO effect fails with a MyError") {\n  assertZIO(effect.exit)(fails(isSubtype[MyError](anything)))\n}\n')))}u.isMDXComponent=!0}}]);